        -:    0:Source:PipelineHandler.hpp
        -:    1:#pragma once
        -:    2:#include <sys/socket.h>
        -:    3:#include <unistd.h>
        -:    4:
        -:    5:#include <condition_variable>
        -:    6:#include <functional>
        -:    7:#include <future>
        -:    8:#include <memory>
        -:    9:#include <mutex>
        -:   10:#include <queue>
        -:   11:#include <thread>
        -:   12:
        -:   13:#include "CommandHandler.hpp"
        -:   14:
        -:   15:using std::condition_variable;
        -:   16:using std::function;
        -:   17:using std::future;
        -:   18:using std::invalid_argument;
        -:   19:using std::istringstream;
        -:   20:using std::make_shared;
        -:   21:using std::mutex;
        -:   22:using std::queue;
        -:   23:using std::shared_ptr;
        -:   24:using std::string;
        -:   25:using std::thread;
        -:   26:using std::to_string;
        -:   27:using std::unique_lock;
        -:   28:
        -:   29:/**
        -:   30: * @brief Command handler implamented using pipeline and active object pattern
        -:   31: *
        -:   32: */
        -:   33:
        -:   34:class ActiveObject {
        -:   35:   private:
        -:   36:    queue<function<void()>> tasks;
        -:   37:    thread my_thread;
        -:   38:    mutex m;
        -:   39:    condition_variable cv;
        -:   40:    bool stop = false;
        -:   41:
       57:   42:    void run() {
       57:   43:        while (!stop) {
       39:   44:            function<void()> task;
        -:   45:            {
       39:   46:                unique_lock<mutex> lock(m);
      117:   47:                cv.wait(lock, [this] { return !tasks.empty() || stop; });
       39:   48:                if (tasks.empty()) {
       17:   49:                    continue;
        -:   50:                }
       22:   51:                task = tasks.front();
       22:   52:                tasks.pop();
        -:   53:            }
       22:   54:            task();
        -:   55:        }
       18:   56:    }
        -:   57:
        -:   58:   public:
       36:   59:    ActiveObject() : my_thread([this] { run(); }) {}
------------------
_ZN12ActiveObjectC2Ev:
       18:   59:    ActiveObject() : my_thread([this] { run(); }) {}
------------------
_ZZN12ActiveObjectC4EvENKUlvE_clEv:
       18:   59:    ActiveObject() : my_thread([this] { run(); }) {}
------------------
        -:   60:
       18:   61:    ~ActiveObject() {
        -:   62:        {
       18:   63:            unique_lock<mutex> lock(m);
       18:   64:            stop = true;
        -:   65:        }
       18:   66:        cv.notify_all();
       18:   67:        my_thread.join();
       18:   68:    }
        -:   69:
        -:   70:    template <typename F, typename... Args>
       22:   71:    auto invoke(F &&f, Args &&...args) -> future<decltype(f(args...))> {
        -:   72:        using return_type = decltype(f(args...));
       44:   73:        auto task = make_shared<std::packaged_task<return_type()>>(std::bind(std::forward<F>(f), std::forward<Args>(args)...));
       22:   74:        auto result = task->get_future();
        -:   75:        {
       22:   76:            unique_lock<mutex> lock(m);
       44:   77:            tasks.emplace([task]() { (*task)(); });
        -:   78:        }
       22:   79:        cv.notify_one();
       44:   80:        return result;
        -:   81:    }
        -:   82:};
        -:   83:
        -:   84:class PipelineStage : public ActiveObject {
        -:   85:   private:
        -:   86:    function<string(string, int)> task;
        -:   87:
        -:   88:   public:
        -:   89:    shared_ptr<PipelineStage> next_stage;
       18:   90:    PipelineStage(function<string(string, int)> task, shared_ptr<PipelineStage> next_stage)
       18:   91:        : task(std::move(task)), next_stage(next_stage) {}
        -:   92:
       22:   93:    future<string> process(string input, int user_fd) {
       52:   94:        return invoke([this, input, user_fd] {
       30:   95:            string output = (task(input, user_fd));
       14:   96:            if (next_stage != nullptr) {
        8:   97:                output = next_stage->process(output, user_fd).get();
        -:   98:            }
       14:   99:            return output;
       22:  100:        });
        -:  101:    }
        -:  102:};
        -:  103:
        -:  104:class PipelineHandler : public CommandHandler {
        -:  105:   private:
        -:  106:    shared_ptr<PipelineStage> new_graph_stage;
        -:  107:    shared_ptr<PipelineStage> add_edge_stage;
        -:  108:    shared_ptr<PipelineStage> remove_edge_stage;
        -:  109:    shared_ptr<PipelineStage> mst_init_stage;
        -:  110:    shared_ptr<PipelineStage> mst_weight_stage;
        -:  111:    shared_ptr<PipelineStage> mst_longest_stage;
        -:  112:    shared_ptr<PipelineStage> mst_shortest_stage;
        -:  113:    shared_ptr<PipelineStage> mst_avg_stage;
        -:  114:    shared_ptr<PipelineStage> print_graph_stage;
        -:  115:
        3:  116:    string add_edge(string input, int user_fd) {
        5:  117:        istringstream iss(input);
        -:  118:        int u, v, w;
        3:  119:        if (!(iss >> u >> v >> w)) {
        1:  120:            throw invalid_argument("Invalid input - expected u, v, and w");
        -:  121:        }
        2:  122:        if (u <= 0 || u > graph_per_user[user_fd].first.V() || v <= 0 || v > graph_per_user[user_fd].first.V() || u == v) {
        1:  123:            throw invalid_argument("Invalid input - invalid edge. Edge must be between 1 and " + to_string(graph_per_user[user_fd].first.V()) + " and u != v. Got: " + to_string(u) + " " + to_string(v));
        -:  124:        }
        -:  125:
        1:  126:        if (w <= 0) {
    #####:  127:            throw invalid_argument("Invalid input - invalid weight. Weight must be greater than 0. Got: " + to_string(w));
        -:  128:        }
        -:  129:
        1:  130:        graph_per_user[user_fd].first.addEdge(u - 1, v - 1, w);
        1:  131:        graph_per_user[user_fd].first.addEdge(v - 1, u - 1, w);
        -:  132:
        2:  133:        return "edge added\n";
        -:  134:    }
        -:  135:
        3:  136:    string remove_edge(string input, int user_fd) {
        5:  137:        istringstream iss(input);
        -:  138:        int u, v;
        3:  139:        if (!(iss >> u >> v)) {
        1:  140:            throw invalid_argument("Invalid input - expected u and v");
        -:  141:        }
        2:  142:        if (u <= 0 || u > graph_per_user[user_fd].first.V() || v <= 0 || v > graph_per_user[user_fd].first.V() || u == v) {
        1:  143:            throw invalid_argument("Invalid input - invalid edge. Edge must be between 1 and " + to_string(graph_per_user[user_fd].first.V()) + " and u != v. Got: " + to_string(u) + " " + to_string(v));
        -:  144:        }
        -:  145:
        1:  146:        graph_per_user[user_fd].first.removeEdge(u - 1, v - 1);
        1:  147:        graph_per_user[user_fd].first.removeEdge(v - 1, u - 1);
        -:  148:
        2:  149:        return "edge removed\n";
        -:  150:    }
        -:  151:
        2:  152:    string mst_init(string input, int user_fd) {
        2:  153:        MSTSolver *solver = mst_factory.createMSTSolver(input);
        4:  154:        TreeOnGraph mst = solver->getMST(graph_per_user[user_fd].first);
        2:  155:        graph_per_user[user_fd].second = mst;
        2:  156:        delete solver;
        4:  157:        return mst.toString();
        -:  158:    }
        -:  159:
        2:  160:    string mst_weight(string input, int user_fd) {
        4:  161:        return input + "Weight: " + to_string(graph_per_user[user_fd].second.getWeight()) + "\n";
        -:  162:    }
        -:  163:
        2:  164:    string mst_longest(string input, int user_fd) {
        4:  165:        return input + "Longest distance: " + to_string(graph_per_user[user_fd].second.longestDist()) + "\n";
        -:  166:    }
        -:  167:
        2:  168:    string mst_shortest(string input, int user_fd) {
        4:  169:        return input + "Shortest distance: " + to_string(graph_per_user[user_fd].second.shortestDist()) + "\n";
        -:  170:    }
        -:  171:
        2:  172:    string mst_avg(string input, int user_fd) {
        4:  173:        return input + "Average distance: " + to_string(graph_per_user[user_fd].second.avgDist()) + "\n";
        -:  174:    }
        -:  175:
        -:  176:   public:
        2:  177:    PipelineHandler(map<int, pair<Graph, TreeOnGraph>> &graph_per_user, MSTFactory &mst_factory) : CommandHandler(graph_per_user, mst_factory) {
        7:  178:        new_graph_stage = make_shared<PipelineStage>([this](string input, int user_fd) { return init_graph(input, user_fd); }, nullptr);
        5:  179:        add_edge_stage = make_shared<PipelineStage>([this](string input, int user_fd) { return add_edge(input, user_fd); }, nullptr);
        5:  180:        remove_edge_stage = make_shared<PipelineStage>([this](string input, int user_fd) { return remove_edge(input, user_fd); }, nullptr);
        4:  181:        mst_avg_stage = make_shared<PipelineStage>([this](string input, int user_fd) { return mst_avg(input, user_fd); }, nullptr);
        4:  182:        mst_shortest_stage = make_shared<PipelineStage>([this](string input, int user_fd) { return mst_shortest(input, user_fd); }, mst_avg_stage);
        4:  183:        mst_longest_stage = make_shared<PipelineStage>([this](string input, int user_fd) { return mst_longest(input, user_fd); }, mst_shortest_stage);
        4:  184:        mst_weight_stage = make_shared<PipelineStage>([this](string input, int user_fd) { return mst_weight(input, user_fd); }, mst_longest_stage);
        4:  185:        mst_init_stage = make_shared<PipelineStage>([this](string input, int user_fd) { return mst_init(input, user_fd); }, mst_weight_stage);
        3:  186:        print_graph_stage = make_shared<PipelineStage>([this](string input, int user_fd) { return this->graph_per_user[user_fd].first.toString(); }, nullptr);
        2:  187:    }
        -:  188:
       16:  189:    string handle(string input, int user_fd) override {
       16:  190:        string ans = "Got input: " + input;
       32:  191:        istringstream iss(input);
       32:  192:        string command;
       16:  193:        iss >> command;
        -:  194:
       16:  195:        std::cout << "client " << user_fd << " sent: " << input << std::endl;
        -:  196:
        -:  197:        // update the input to be the rest of the input
       16:  198:        getline(iss, input);
        -:  199:
        -:  200:        try {
       16:  201:            if (command == NEW_GRAPH) {
       13:  202:                ans += new_graph_stage->process(input, user_fd).get();
       11:  203:            } else if (command == ADD_EDGE) {
        7:  204:                ans += add_edge_stage->process(input, user_fd).get();
        8:  205:            } else if (command == REMOVE_EDGE) {
        7:  206:                ans += remove_edge_stage->process(input, user_fd).get();
        5:  207:            } else if (command == MST_PRIME || command == MST_KRUSKAL) {
        2:  208:                ans += mst_init_stage->process(command, user_fd).get();
        3:  209:            } else if (command == PRINT_GRAPH) {
        1:  210:                ans += print_graph_stage->process(input, user_fd).get();
        -:  211:            } else {
        2:  212:                ans += "Invalid command";
        -:  213:            }
        8:  214:        } catch (const invalid_argument &e) {
        8:  215:            ans += "Error: " + string(e.what()) + '\n';
        -:  216:        }
        -:  217:
       16:  218:        if (ans.back() != '\n') {
        2:  219:            ans += '\n';
        -:  220:        }
        -:  221:
       16:  222:        std::cout << "server sent: to client " << user_fd << ": " << ans << std::endl;
        -:  223:
       32:  224:        return ans;
        -:  225:    }
        -:  226:
        1:  227:    void stop() override {}  // NO NEED TO IMPLEMENT  - stop is implemented in the destructor of the ActiveObject , sherd_ptr will be deleted and the destructor will be called
        -:  228:};
