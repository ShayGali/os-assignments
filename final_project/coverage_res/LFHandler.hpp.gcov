        -:    0:Source:LFHandler.hpp
        -:    1:#pragma once
        -:    2:#include <condition_variable>
        -:    3:#include <functional>
        -:    4:#include <future>
        -:    5:#include <mutex>
        -:    6:#include <queue>
        -:    7:#include <thread>
        -:    8:#include <vector>
        -:    9:
        -:   10:constexpr int MAX_THREADS = 4;
        -:   11:
        -:   12:class LeaderFollower {
        -:   13:   private:
        -:   14:    std::queue<std::function<void()>> tasks;  // FIFO queue
        -:   15:    std::mutex mutex;                         // Protects tasks
        -:   16:    std::condition_variable cv;               // Signals a task is available
        -:   17:    std::vector<std::thread> threads;         // Worker threads
        -:   18:    bool stop;                                // Signals to worker threads to stop
        -:   19:
        -:   20:    /**
        -:   21:     * will be called by each worker thread
        -:   22:     * will wait for a task to be available and execute it
        -:   23:     */
       28:   24:    void workerThread() {
        -:   25:        while (true) {
       28:   26:            std::unique_lock<std::mutex> lock(mutex);  // lock the mutex
        -:   27:
        -:   28:            // Wait for a task to be available
       83:   29:            cv.wait(lock, [this] { return !tasks.empty() || stop; });
        -:   30:
        -:   31:            // Check if we should stop
       28:   32:            if (stop && tasks.empty()) {
       24:   33:                return;
        -:   34:            }
        -:   35:
        -:   36:            // Leader takes a task
       16:   37:            auto task = std::move(tasks.front());
       16:   38:            tasks.pop();
        -:   39:
        -:   40:            // Leader becomes a follower
       16:   41:            lock.unlock();
        -:   42:
        -:   43:            // Execute the task
       16:   44:            task();
       44:   45:        }
        -:   46:    }
        -:   47:
        -:   48:   public:
        3:   49:    LeaderFollower() : stop(false) {
       15:   50:        for (size_t i = 0; i < MAX_THREADS; ++i) {
        -:   51:            // Create worker threads
       12:   52:            threads.emplace_back(&LeaderFollower::workerThread, this);
        -:   53:        }
        3:   54:    }
        -:   55:
        3:   56:    ~LeaderFollower() {
        -:   57:        {
        3:   58:            std::unique_lock<std::mutex> lock(mutex);
        3:   59:            stop = true;  // Signal to worker threads to stop
        3:   60:        }
        3:   61:        cv.notify_all();  // Wake up all worker threads
        -:   62:
        -:   63:        // Wait for all worker threads to finish
       15:   64:        for (auto &thread : threads) {
       12:   65:            thread.join();
        -:   66:        }
        3:   67:    }
        -:   68:
        -:   69:    /**
        -:   70:     * Add a task to the queue and return a future that will be set once the task is complete
        -:   71:     */
        -:   72:    template <typename F>
       16:   73:    auto addTask(F &&task) -> std::future<typename std::result_of<F()>::type> {
        -:   74:        // Get the return type of the task
        -:   75:        using ReturnType = typename std::result_of<F()>::type;
        -:   76:
        -:   77:        // Create a promise to set the result of the task
       16:   78:        auto promise = std::make_shared<std::promise<ReturnType>>();
        -:   79:
        -:   80:        // Get the future from the promise
       16:   81:        auto future = promise->get_future();
        -:   82:
        -:   83:        {  // add the task to the queue
       16:   84:            std::unique_lock<std::mutex> lock(mutex);
       32:   85:            tasks.emplace([promise, task = std::forward<F>(task)]() mutable {
        -:   86:                try {
        -:   87:                    if constexpr (std::is_void<ReturnType>::value) {
        -:   88:                        task();
        -:   89:                        promise->set_value();
        -:   90:                    } else {
       16:   91:                        promise->set_value(task());
        -:   92:                    }
    =====:   93:                } catch (...) {
    =====:   94:                    promise->set_exception(std::current_exception());
        -:   95:                }
        -:   96:            });
       16:   97:        }
       16:   98:        cv.notify_one();  // Wake up one worker thread
       32:   99:        return future;
       16:  100:    }
        -:  101:
        2:  102:    void stop_service() {
        2:  103:        std::unique_lock<std::mutex> lock(mutex);
        2:  104:        stop = true;
        2:  105:    }
        -:  106:};
        -:  107:
        -:  108:class LFHandler : public CommandHandler {
        -:  109:   private:
        -:  110:    LeaderFollower lf;  // Leader-Follower pattern
        -:  111:    string cmd_handler(string input, int user_fd);
        -:  112:
        -:  113:   public:
        3:  114:    LFHandler(map<int, pair<Graph, TreeOnGraph>> &graph_per_user, MSTFactory &mst_factory)
        3:  115:        : CommandHandler(graph_per_user, mst_factory) {}
        -:  116:
        -:  117:    /**
        -:  118:     * Handle the input command
        -:  119:     * will get a string input and a user file descriptor.
        -:  120:     * add new task to the Leader-Follower pattern
        -:  121:     */
       16:  122:    string handle(string input, int user_fd) override {
       16:  123:        auto future = lf.addTask([this, input, user_fd] {
       16:  124:            string ans = cmd_handler(input, user_fd);
       16:  125:            return ans;
       16:  126:        });
       32:  127:        return future.get();  // Wait for the task to complete and get the result
       16:  128:    }
        -:  129:
        2:  130:    void stop() override {
        2:  131:        lf.stop_service();
        2:  132:    }
        -:  133:};
        -:  134:
        -:  135:/**
        -:  136: * Handle the input command
        -:  137: */
       16:  138:string LFHandler::cmd_handler(string input, int user_fd) {
       16:  139:    string ans = "Got input: " + input;
       16:  140:    string command;
       16:  141:    istringstream iss(input);
        -:  142:    int u, v, w;
        -:  143:
       16:  144:    Graph &g = graph_per_user[user_fd].first;
       16:  145:    iss >> command;
        -:  146:
       16:  147:    std::cout << "client " << user_fd << " sent: " << input << std::endl;
        -:  148:
        -:  149:    try {
       16:  150:        if (command == NEW_GRAPH) {
        5:  151:            string remaining_input;
        5:  152:            getline(iss, remaining_input);
        9:  153:            ans += init_graph(remaining_input, user_fd);
        1:  154:            ans += "New graph created";
        -:  155:
       16:  156:        } else if (command == ADD_EDGE) {
        -:  157:            // get u and v from the input
        3:  158:            if (!(iss >> u >> v >> w)) {  // if the buffer is empty we throw an error
        1:  159:                ans += "Invalid input - expected format: u v w\n";
        1:  160:                return ans;
        -:  161:            }
        2:  162:            g.addEdge(u - 1, v - 1, w);
        1:  163:            g.addEdge(v - 1, u - 1, w);
        -:  164:
        8:  165:        } else if (command == REMOVE_EDGE) {
        3:  166:            if (!(iss >> u >> v)) {
        1:  167:                ans += "Invalid input - expected u and v\n";
        1:  168:                return ans;
        -:  169:            }
        2:  170:            g.removeEdge(u - 1, v - 1);
        1:  171:            g.removeEdge(v - 1, u - 1);
        5:  172:        } else if (command == MST_PRIME || command == MST_KRUSKAL) {
        2:  173:            MSTSolver *solver = mst_factory.createMSTSolver(command);
        2:  174:            TreeOnGraph mst = solver->getMST(g);
        2:  175:            graph_per_user[user_fd].second = mst;
        2:  176:            ans += "MST: \n" + mst.toString();
        -:  177:
        -:  178:            // do calculations
        -:  179:            // add weight
        2:  180:            ans += "Weight: " + std::to_string(mst.getWeight()) + "\n";
        -:  181:            // add longest distance
        2:  182:            ans += "Longest distance: " + std::to_string(mst.longestDist()) + "\n";
        -:  183:            // add shortest distance
        2:  184:            ans += "Shortest distance: " + std::to_string(mst.shortestDist()) + "\n";
        -:  185:            // add average distance
        2:  186:            ans += "Average distance: " + std::to_string(mst.avgDist()) + "\n";
        2:  187:            delete solver;
        5:  188:        } else if (command == PRINT_GRAPH) {
        1:  189:            ans = g.toString();
        -:  190:        } else {
        2:  191:            ans += "Invalid command";
        -:  192:        }
        6:  193:    } catch (const std::exception &e) {
        6:  194:        ans += "Error: " + string(e.what());
        6:  195:    }
        -:  196:
        -:  197:    // ad LF if needed
       14:  198:    if (ans.back() != '\n') {
        9:  199:        ans += "\n";
        -:  200:    }
        -:  201:
       14:  202:    std::cout << "server sent: to client " << user_fd << ": " << ans << std::endl;
        -:  203:
       14:  204:    return ans;
       16:  205:}
