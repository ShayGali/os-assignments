        -:    0:Source:Graph.cpp
        -:    1:#include "Graph.hpp"
        -:    2:
        -:    3:#include <stdexcept>
        -:    4:
       22:    5:Graph::Graph(int n) {
       22:    6:    adjMat = vector<vector<int>>(n, vector<int>(n, NO_EDGE));
       22:    7:}
        -:    8:
       19:    9:void Graph::addEdge(size_t u, size_t v, int weight) {
       19:   10:    if (u < 0 || u >= adjMat.size() || v < 0 || v >= adjMat.size()) {
        1:   11:        throw std::invalid_argument("Invalid vertex index");
        -:   12:    }
        -:   13:
       18:   14:    if(weight <= 0) {
    #####:   15:        throw std::invalid_argument("Invalid weight");
        -:   16:    }
        -:   17:
       18:   18:    adjMat[u][v] = weight;
       18:   19:}
        -:   20:
        3:   21:void Graph::removeEdge(size_t u, size_t v) {
        3:   22:    if (u < 0 || u >= adjMat.size() || v < 0 || v >= adjMat.size()) {
        1:   23:        throw std::invalid_argument("Invalid vertex index");
        -:   24:    }
        2:   25:    adjMat[u][v] = NO_EDGE;
        2:   26:}
        -:   27:
        3:   28:vector<int> Graph::getNeighbors(size_t u) const {
        3:   29:    if (u < 0 || u >= adjMat.size()) {
    #####:   30:        throw std::invalid_argument("Invalid vertex index");
        -:   31:    }
        3:   32:    vector<int> neighbors;
       12:   33:    for (size_t i = 0; i < adjMat.size(); i++) {
        9:   34:        if (adjMat[u][i] != NO_EDGE) {
        6:   35:            neighbors.push_back(i);
        -:   36:        }
        -:   37:    }
        -:   38:
        3:   39:    return neighbors;
        -:   40:}
        -:   41:
       16:   42:const vector<vector<int>>& Graph::getAdjMat() const {
       16:   43:    return adjMat;
        -:   44:}
        -:   45:
       10:   46:int Graph::getWeight(size_t u, size_t v) const {
      10*:   47:    if (u < 0 || u >= adjMat.size() || v < 0 || v >= adjMat.size()) {
    #####:   48:        throw std::invalid_argument("Invalid vertex index");
        -:   49:    }
       10:   50:    return adjMat[u][v];
        -:   51:}
        -:   52:
        5:   53:int Graph::V() const {
        5:   54:    return adjMat.size();
        -:   55:}
        -:   56:
        -:   57:/**
        -:   58: * @brief Get the edges of the graph. (the graph is undirected)
        -:   59: */
        3:   60:vector<Edge> Graph::getEdges() const {
        -:   61:    // the graph is undirected, so we need to iterate only over the upper triangle of the matrix
        3:   62:    vector<Edge> edges;
       12:   63:    for (size_t i = 0; i < adjMat.size(); i++) {
       18:   64:        for (size_t j = i + 1; j < adjMat.size(); j++) {
        9:   65:            if (adjMat[i][j] != NO_EDGE) {
        7:   66:                edges.push_back({i, j, adjMat[i][j]});
        -:   67:            }
        -:   68:        }
        -:   69:    }
        -:   70:
        3:   71:    return edges;
        -:   72:}
        -:   73:
        1:   74:string Graph::toString() const {
        1:   75:    string str = "";
        4:   76:    for (size_t i = 0; i < adjMat.size(); i++) {
        6:   77:        for (size_t j = i + 1; j < adjMat.size(); j++) {
        3:   78:            if (adjMat[i][j] != NO_EDGE) {
        3:   79:                str += std::to_string(i + 1) + " <-> " + std::to_string(j + 1) + " , " + std::to_string(adjMat[i][j]) + "\n";
        -:   80:            }
        -:   81:        }
        -:   82:    }
        1:   83:    return str;
        -:   84:}
